- Tengo android 2.3.3 y libgdx ahora soporta android 3.1.2. Puedo tener ambos ides?
- Debo usar una skin
- me queda la duda de si implemento el dispose en alguna pantalla y hago super.dispose..a cual hide llama? al de la clase derivada o la madre?
supongo la derivada porque arranca a ejecutar desde abajo, pero tengo la duda.

HACER
- a medida que pasa el tiempo (level 50) la brecha se agranda entre las texturas.
- el armado del paralax deberia ir en cada asset que sabe como constuir el fondo, no se, pero no en gameworld creo.
- hacer un skin
- en las settings debo meter algo que permita usar low o high por el paralax.
- poner algun efecto de particulas cuando salte o nube.
- agregar un obstaculo
- programar los movimientos de las plataformas
- random texture plataformas
- menus y todo eso
- musica y efectos
- pensar alguna manera de que al apretar reload no se cargue el mismo background que ya tenia, usar una property?
o arrancar desde 1 (valor de property) e incrementar con modulo.
- MAS NADA, LA FUNCIONALIDAD ES ESA.
- Debo ver cuando hacer save de las propiedades


LECCIONES APRENDIDAS
--------------------
1) Primero existía ApplicationListener, todas las pantallas heredaban de allí.
Los métodos de ApplicationListener son:
create, resize, render, pause, resume, dispose.

Su ciclo de vida para android está descripto acá:
https://github.com/libgdx/libgdx/wiki/The-life-cycle

Luego libgdx inventó la clase Game para ayudar a los programadores a moverse entre pantallas.
Entonces ahora las aplicaciones pueden extender Game para usar sus métodos setScreen y getScreen.
Junto con el desarrollo de la clase Game vino la interfaz Screen.
Screen agrega 2 métodos nuevos que utiliza la clase Game: show y hide.
Entonces la interfaz playScreen tiene: show, hide, create, resize, render, pause, resume, dispose.
Si yo heredo de Game, cuando uso su "setScreen" la clase Game hace lo siguiente:
- invoca al método hide de la pantalla vieja.
- invoca al método show (automáticamente libgdx antes invocó al método create) y luego resize de la pantalla nueva.

Game invoca a hide (y no a dispose) supongo para dar más flexibilidad al manejo de pantallas.

Yo para hacer las transiciones necesito reescribir toda la clase Game. Entonces creé una nueva llamada DirectGame que básicamente
reutiliza la mecánica de Game (es decir, usa los métodos show y hide con el mismo propósito).
La única diferencia (además de ejecutar la transición) es que necesito pausar la pantalla mientras la transición se hace y al finalizar la
transición invoco al método resume.
Para no usar el método pause y dar más flexibilidad, definí un método nuevo llamado stop.

2) Para ejecutar la versión html: Ir al directorio del juego y ejecutar gradlew html:dist. En GameFour\html\build\dist quedó
la aplicación a deployar. Para ejecutarla en xampp copiar ese contenido dentro de C:\xampp\htdocs\Alvaro\juego y luego
levantar el apache y el tomcat del xampp y ejecutar http://localhost/Alvaro/juego/index.html

3) Para usar el editor de partículas mejor ejecutar el editor desde Android Studio ya que lo ejecuta desde la versión de libgdx que tengo.
Para ello seguir este link https://www.gamefromscratch.com/post/2014/11/03/LibGDX-Tutorial-Part-15-Particles-Part-One-2D-Particles.aspx.
Lo importante es que arriba del todo diga "Pixel per meter 100" (mi PPM) y "zoom level = 1" asi puedo ver en tamaño real el efecto.
Todas las dimensiones deben ir en metros (ej: spawn width, X size, etc.), lo mismo con las velocidades.
Estas propiedades son por cada emiter, si hay más de un emiter debo seleccionarlo para editar sus propiedades.