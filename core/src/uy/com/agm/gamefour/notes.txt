- Tengo android 2.3.3 y libgdx ahora soporta android 3.1.2. Puedo tener ambos ides?
- Para la ejecutar le version html: Ir al directorio del juego y ejecutar gradlew html:dist. En GameFour\html\build\dist quedo
la aplicación a deployar. Para ejecutarla en xampp copiar ese contenido dentro de C:\xampp\htdocs\juego y luego
levantar el apache y el tomcat del xampp y ejecutar http://localhost/juego/index.html
- Debo usar una skin
- me queda la duda de si implemento el dispose en alguna pantalla y hago super.dispose..a cual hide llama? al de la clase derivada o la madre?
- En html, incio full y luego achico y no se actualiza la pantalla.

LECCIONES APRENDIDAS
--------------------
- Primero existía ApplicationListener, todas las pantallas heredaban de allí.
Los métodos de ApplicationListener son:
create, resize, render, pause, resume, dispose.

Su ciclo de vida para android está descripto acá:
https://github.com/libgdx/libgdx/wiki/The-life-cycle

Luego libgdx inventó la clase Game para ayudar a los programadores a moverse entre pantallas.
Entonces ahora las aplicaciones pueden extender Game para usar sus métodos setScreen y getScreen.
Junto con el desarrollo de la clase Game vino la interfaz Screen.
Screen agrega 2 métodos nuevos que utiliza la clase Game: show y hide.
Entonces la interfaz playScreen tiene: show, hide, create, resize, render, pause, resume, dispose.
Si yo heredo de Game, cuando uso su "setScreen" la clase Game hace lo siguiente:
- invoca al método hide de la pantalla vieja.
- invoca al método show (automáticamente libgdx antes invocó al método create) y luego resize de la pantalla nueva.

Game invoca a hide (y no a dispose) supongo para dar más flexibilidad al manejo de pantallas.

Yo para hacer las transiciones necesito reescribir toda la clase Game. Entonces creé una nueva llamada DirectGame que básicamente
reutiliza la mecánica de Game (es decir, usa los métodos show y hide con el mismo propósito).
La única diferencia (además de ejecutar la transición) es que necesito pausar la pantalla mientras la transición se hace y al finalizar la
transición invoco al método resume.
Para no usar el método pause y dar más flexibilidad, definí un método nuevo llamado stop.
