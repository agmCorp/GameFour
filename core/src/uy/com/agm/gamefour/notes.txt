- Tengo android 2.3.3 y libgdx ahora soporta android 3.1.2. Puedo tener ambos IDES?
- Debo usar una skin
- me queda la duda de si implemento el dispose en alguna pantalla y hago super.dispose..a cual hide llama? al de la clase derivada o la madre?
supongo la derivada porque arranca a ejecutar desde abajo, pero tengo la duda.

HACER
- clase bullet con sonido.
- Hacer un keystore para este juego
- Poner por defecto un highscore razonable y ver lo de averagePlayer
- Estudiar la memoria consumida


DESEABLE PARA LIBERAR
- a medida que pasa el tiempo (level 50) la brecha se agranda entre las texturas.
- agregar mas fondos

OTROS
- hacer un skin
- en las settings debo meter algo que permita usar low o high por el paralax (boton four state off, low, medium, high)
- Poner una zona de salto perfecto. Si el pajaro cae justo ahi (su x en medio de la plataforma + delta) saco algun cartel y/o doy
puntos extra.
- a veces queda una distancia muy larga entre los cohetes (sobre el eje y). Me parece que es porque se estaban moviendo y luego el movimiento
se detiene al cambiar de nivel.
- Revisar que pasa después que choca peque no veo que dispare. Capaz es peque cae rápido
- MAS NADA, LA FUNCIONALIDAD ES ESA.

LECCIONES APRENDIDAS
--------------------
1) Primero existía ApplicationListener, todas las pantallas heredaban de allí.
Los métodos de ApplicationListener son:
create, resize, render, pause, resume, dispose.

Su ciclo de vida para android está descripto acá:
https://github.com/libgdx/libgdx/wiki/The-life-cycle

Luego libgdx inventó la clase Game para ayudar a los programadores a moverse entre pantallas.
Entonces ahora las aplicaciones pueden extender Game para usar sus métodos setScreen y getScreen.
Junto con el desarrollo de la clase Game vino la interfaz Screen.
Screen agrega 2 métodos nuevos que utiliza la clase Game: show y hide.
Entonces la interfaz playScreen tiene: show, hide, create, resize, render, pause, resume, dispose.
Si yo heredo de Game, cuando uso su "setScreen" la clase Game hace lo siguiente:
- invoca al método hide de la pantalla vieja.
- invoca al método show (automáticamente libgdx antes invocó al método create) y luego resize de la pantalla nueva.

Game invoca a hide (y no a dispose) supongo para dar más flexibilidad al manejo de pantallas.

Yo para hacer las transiciones necesito reescribir toda la clase Game. Entonces creé una nueva llamada DirectGame que básicamente
reutiliza la mecánica de Game (es decir, usa los métodos show y hide con el mismo propósito).
La única diferencia (además de ejecutar la transición) es que necesito pausar la pantalla mientras la transición se hace y al finalizar la
transición invoco al método resume.
Para no usar el método pause y dar más flexibilidad, definí un método nuevo llamado stop.

2) Para ejecutar la versión html: Ir al directorio del juego y ejecutar gradlew html:dist. En GameFour\html\build\dist quedó
la aplicación a deployar. Para ejecutarla en xampp copiar ese contenido dentro de C:\xampp\htdocs\Alvaro\juego y luego
levantar el apache y el tomcat del xampp y ejecutar http://localhost/Alvaro/juego/index.html

3) Para usar el editor de partículas mejor ejecutar el editor desde Android Studio ya que lo ejecuta desde la versión de libgdx que tengo.
Para ello seguir este link https://www.gamefromscratch.com/post/2014/11/03/LibGDX-Tutorial-Part-15-Particles-Part-One-2D-Particles.aspx.
Con respecto al efecto (archivo .p), lo importante es que arriba del todo al abrirlo diga "Pixel per meter 100" (mi PPM) y "zoom level = 1"
asi puedo ver en tamaño real el efecto.
Todas las dimensiones deben ir en metros (ej: spawn width, X size, etc.), lo mismo con las velocidades.
Estas propiedades son por cada emiter, si hay más de un emiter debo seleccionarlo para editar sus propiedades.

4) Para incluir TypingLabel y poder usarla en html hice lo siguiente:
En html/src/GdxDefinition.gwt.xml agregué:
<inherits name='TypingLabel' />

Luego dentro de GameFour/core/src cree un archivo llamado TypingLabel.gwt.xml cuyo contenido es el siguiente:
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE module PUBLIC "-//Google Inc.//DTD Google Web Toolkit trunk//EN" "http://google-web-toolkit.googlecode.com/svn/trunk/distro-source/core/src/gwt-module.dtd">
<module>
<source path="com/rafaskoberg/gdx/typinglabel" /> <--- RUTA EN DONDE ESTÁN LOS FUENTES PARA QUE GWT GENERE JAVASCRIPT A PARTIR DE ELLOS.
</module>

Me bajé los fuentes desde este link:
https://github.com/rafaskb/typing-label
Es necesario bajar los fuentes porque los voy a tener que modificar para hacerlos compatibles con GWT.

Copié los fuentes dentro de GameFour/core/src.
Líneas 35 y 36 de TypingLabel antes:
private final ObjectMap<String, String> variables = new ObjectMap<>();
protected final Array<TokenEntry> tokenEntries = new Array<>();
Línes 35 y 36 de TypingLabel después:
private final ObjectMap<String, String> variables = new ObjectMap<String, String>();
protected final Array<TokenEntry> tokenEntries = new Array<TokenEntry>();

Ver reflection en libgdx: https://github.com/libgdx/libgdx/wiki/Reflection
Línea 448 de TypingLabel antes:
antes decía if (effectClass.isAssignableFrom(effect.getClass())) {
Línea 448 de TypingLabel después:
ahora dice if (ClassReflection.isAssignableFrom(effectClass.getClass(), effect.getClass())) {

Estos fuentes SOLO SE VAN A USAR para GWT.
Para android y desktop voy a usar el jar bajado por maven/gradle.
Para bajarme el jar editar GameFour/build.gradle:
   ext {
       appName = "GameFour"
       gdxVersion = '1.9.8'
       roboVMVersion = '2.3.1'
       box2DLightsVersion = '1.4'
       ashleyVersion = '1.7.0'
       aiVersion = '1.8.0'
       admobVersion = '15.0.1'
       ---> typingLabelVersion = '1.0.4'
   }

project(":core") {
   apply plugin: "java"

   dependencies {
       compile "com.badlogicgames.gdx:gdx:$gdxVersion"
       compile "com.badlogicgames.gdx:gdx-box2d:$gdxVersion"
       ---> compile "com.rafaskoberg.gdx:typing-label:$typingLabelVersion"

       // To use external jars just place them in a directory called GameThree/libs
       compile fileTree(dir: '../libs', include: ['*.jar'])
   }
}

Eso me trajo el jar dentro de External libraries (ahora figura typing-label-1.04).
Con esto, TypingLabel funciona en desktop y android pero todavía no en html.

TypingLabel usa java.util.regex package que no está soportada por GWT, por lo tanto al generar html (gradlew html:dist) da error en la clase Parser.
Ver incidente ttps://github.com/rafaskb/typing-label/issues/1
La solución es usar la librería RegExodus.
Esta librería la bajo (al igual que su fuente) y es soportada por GWT.
Dentro del jar tiene un package regexodus.emu.java.util.regex con clases que emulan java.util.regex (de jse) y además ya contiene el archivo regexodus.gwt.xml por lo que usarla es muy transparente.

Para usarla entonces hago lo siguiente:
Dentro de GameFour/build.gradle
   ext {
       appName = "GameFour"
       gdxVersion = '1.9.8'
       roboVMVersion = '2.3.1'
       box2DLightsVersion = '1.4'
       ashleyVersion = '1.7.0'
       aiVersion = '1.8.0'
       admobVersion = '15.0.1'
       typingLabelVersion = '1.0.4'
       ---> regexodusVersion = '0.1.10'
   }

project(":core") {
   apply plugin: "java"

   dependencies {
       compile "com.badlogicgames.gdx:gdx:$gdxVersion"
       compile "com.badlogicgames.gdx:gdx-box2d:$gdxVersion"
       compile "com.rafaskoberg.gdx:typing-label:$typingLabelVersion"
       ---> compile "com.github.tommyettinger:regexodus:$regexodusVersion"
       ---> compile "com.github.tommyettinger:regexodus:$regexodusVersion:sources"

       // To use external jars just place them in a directory called GameThree/libs
       compile fileTree(dir: '../libs', include: ['*.jar'])
   }
}

En html/src/GdxDefinition.gwt.xml agregué:
<inherits name='regexodus' />

Con esto, lo que hago es referenciar al archivo regexodus.gwt.xml que está dentro de los sources bajados (que quedaron dentro de External Libraries/regexodus-0.1.10-sources).
Ese archivo tiene el mapeo a los .java necesarios para que GWT genere javascript a partir de ellos.
Luego de todo esto, ya estaría en condiciones de usar TypingLabel en html.

5) Para hacer un "Pull request" ver este video:
https://www.youtube.com/watch?v=dSl_qnWO104

Básicamente es hacer un fork del proyecto en cuestión y luego esta secuencia de comandos:

mkdir carpeta
cd carpeta
git clone URL COPIADA LUEGO DEL FORK PRESIONANDO EL BOTÓN "CLONE OR DOWNLOAD"
cd elProyecto
- luego edito los fuentes con notepad o algún ide
git status 
- veo lo que toqué en rojo
git add .
git status
- veo que lo que toqué haya quedado en verde
git commit -m "Algún comentario"
git push origin  master 
- se sube a mi fork en github y puedo verlo allí
Luego en hitHub uso el botón New pull request, selecciono las branches a comparar (la del dueño del proyecto y la mia) y le doy comparar.
Relleno el formulario con algún comentario y listo.
